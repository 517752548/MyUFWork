-- Generated by CSharp.lua Compiler
local System = System
local QueueInt64 = System.Queue(System.Int64)
local DCET
local DictInt64ITimer
local MultiMap_2Int64Int64
System.import(function (out)
  DCET = out.DCET
  DictInt64ITimer = System.Dictionary(System.Int64, DCET.ITimer)
  MultiMap_2Int64Int64 = DCET.MultiMap_2(System.Int64, System.Int64)
end)
System.namespace("DCET", function (namespace)
  namespace.interface("ITimer", function ()
    return {}
  end)

  namespace.class("OnceWaitTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, callback)
      self.Callback = callback
    end
    return {
      base = function (out)
        return {
          out.DCET.AwakeSystem_2(out.DCET.OnceWaitTimer, System.TaskCompletionSource)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("OnceWaitTimer", function (namespace)
    local Run, __ctor__
    __ctor__ = function (this)
      DCET.Entity.__ctor__(this)
    end
    Run = function (this)
      local tcs = this.Callback
      this:GetParent(DCET.TimerComponent):Remove(this.Id)
      tcs:SetResult(true)
    end
    return {
      base = function (out)
        return {
          out.DCET.Entity,
          out.DCET.ITimer
        }
      end,
      Run = Run,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("OnceTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, callback)
      self.Callback = callback
    end
    return {
      base = function (out)
        return {
          out.DCET.AwakeSystem_2(out.DCET.OnceTimer, System.Delegate)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("OnceTimer", function (namespace)
    local Run, __ctor__
    __ctor__ = function (this)
      DCET.Entity.__ctor__(this)
    end
    Run = function (this)
      System.try(function ()
        this.Callback()
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
      end)
    end
    return {
      base = function (out)
        return {
          out.DCET.Entity,
          out.DCET.ITimer
        }
      end,
      Run = Run,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("RepeatedTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, repeatedTime, callback)
      self:Awake(repeatedTime, callback)
    end
    return {
      base = function (out)
        return {
          out.DCET.AwakeSystem_3(out.DCET.RepeatedTimer, System.Int64, System.Delegate)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("RepeatedTimer", function (namespace)
    local Awake, Run, Dispose, __ctor__
    __ctor__ = function (this)
      DCET.Entity.__ctor__(this)
    end
    Awake = function (this, repeatedTime, callback)
      this.StartTime = DCET.TimeHelper.CurrentLocalMilliseconds()
      this.RepeatedTime = repeatedTime
      this.Callback = callback
      this.Count = 1
    end
    Run = function (this)
      this.Count = this.Count + 1
      local timerComponent = this:GetParent(DCET.TimerComponent)
      local tillTime = this.StartTime + this.RepeatedTime * this.Count
      timerComponent:AddToTimeId(tillTime, this.Id)

      System.try(function ()
        this.Callback()
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
      end)
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      local id = this.Id

      if id == 0 then
        DCET.Log.Error("RepeatedTimer可能多次释放了" .. "")
        return
      end

      DCET.Entity.Dispose(this)

      this.StartTime = 0
      this.RepeatedTime = 0
      this.Callback = nil
      this.Count = 0
    end
    return {
      base = function (out)
        return {
          out.DCET.Entity,
          out.DCET.ITimer
        }
      end,
      Awake = Awake,
      StartTime = 0,
      RepeatedTime = 0,
      Count = 0,
      Run = Run,
      Dispose = Dispose,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("TimerComponentAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      DCET.TimerComponent.Instance = self
    end
    return {
      base = function (out)
        return {
          out.DCET.AwakeSystem_1(out.DCET.TimerComponent)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerComponentUpdateSystem", function (namespace)
    local Update
    Update = function (this, self)
      self:Update()
    end
    return {
      base = function (out)
        return {
          out.DCET.UpdateSystem_1(out.DCET.TimerComponent)
        }
      end,
      Update = Update,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerComponent", function (namespace)
    local Update, WaitTillAsync, WaitTillAsync1, WaitAsync, WaitAsync1, NewRepeatedTimer, GetRepeatedTimer, Remove, 
    NewOnceTimer, GetOnceTimer, AddToTimeId, __ctor__
    __ctor__ = function (this)
      this.timers = DictInt64ITimer()
      this.TimeId = MultiMap_2Int64Int64()
      this.timeOutTime = QueueInt64()
      this.timeOutTimerIds = QueueInt64()
      DCET.Entity.__ctor__(this)
    end
    Update = function (this)
      if this.TimeId:getCount() == 0 then
        return
      end

      local timeNow = DCET.TimeHelper.CurrentLocalMilliseconds()

      if timeNow < this.minTime then
        return
      end

      for _, kv in System.each(this.TimeId:GetDictionary()) do
        local k = kv.Key
        if k > timeNow then
          this.minTime = k
          break
        end
        this.timeOutTime:Enqueue(k)
      end

      while #this.timeOutTime > 0 do
        local time = this.timeOutTime:Dequeue()
        for _, timerId in System.each(this.TimeId:get(time)) do
          this.timeOutTimerIds:Enqueue(timerId)
        end
        this.TimeId:Remove1(time)
      end

      while #this.timeOutTimerIds > 0 do
        local continue
        repeat
          local timerId = this.timeOutTimerIds:Dequeue()
          local timer
          local default
          default, timer = this.timers:TryGetValue(timerId)
          if not default then
            continue = true
            break
          end

          timer:Run()
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    WaitTillAsync = function (this, tillTime, cancellationToken)
      if DCET.TimeHelper.CurrentLocalMilliseconds() > tillTime then
        return System.Task.getCompletedTask()
      end

      local tcs = System.TaskCompletionSource()

      local timer = DCET.EntityFactory.CreateWithParent2(this, tcs, DCET.OnceWaitTimer, System.TaskCompletionSource)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      cancellationToken:Register(function ()
        Remove(this, timer.Id)
      end)
      return tcs:getTask()
    end
    WaitTillAsync1 = function (this, tillTime)
      if DCET.TimeHelper.CurrentLocalMilliseconds() > tillTime then
        return System.Task.getCompletedTask()
      end
      local tcs = System.TaskCompletionSource()
      local timer = DCET.EntityFactory.CreateWithParent2(this, tcs, DCET.OnceWaitTimer, System.TaskCompletionSource)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return tcs:getTask()
    end
    WaitAsync = function (this, time, cancellationToken)
      local tillTime = DCET.TimeHelper.CurrentLocalMilliseconds() + time

      if DCET.TimeHelper.CurrentLocalMilliseconds() > tillTime then
        return System.Task.getCompletedTask()
      end

      local tcs = System.TaskCompletionSource()
      local timer = DCET.EntityFactory.CreateWithParent2(this, tcs, DCET.OnceWaitTimer, System.TaskCompletionSource)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      cancellationToken:Register(function ()
        Remove(this, timer.Id)
      end)
      return tcs:getTask()
    end
    WaitAsync1 = function (this, time)
      local tillTime = DCET.TimeHelper.CurrentLocalMilliseconds() + time
      local tcs = System.TaskCompletionSource()
      local timer = DCET.EntityFactory.CreateWithParent2(this, tcs, DCET.OnceWaitTimer, System.TaskCompletionSource)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return tcs:getTask()
    end
    -- <summary>
    -- 创建一个RepeatedTimer
    -- </summary>
    -- <param name="action"></param>
    -- <returns></returns>
    NewRepeatedTimer = function (this, time, action)
      if time < 30 then
        System.throw(System.Exception("repeated time < 30" .. ""))
      end
      local tillTime = DCET.TimeHelper.CurrentLocalMilliseconds() + time
      local timer = DCET.EntityFactory.CreateWithParent3(this, time, action, DCET.RepeatedTimer, System.Int64, System.Delegate)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return timer.Id
    end
    GetRepeatedTimer = function (this, id)
      local default, timer = this.timers:TryGetValue(id)
      if not default then
        return nil
      end
      return System.as(timer, DCET.RepeatedTimer)
    end
    Remove = function (this, id)
      if id == 0 then
        return
      end
      local timer
      local default
      default, timer = this.timers:TryGetValue(id)
      if not default then
        return
      end
      this.timers:RemoveKey(id);

      local extern = (System.as(timer, System.IDisposable))
      if extern ~= nil then
        extern:Dispose()
      end
    end
    NewOnceTimer = function (this, tillTime, action)
      local timer = DCET.EntityFactory.CreateWithParent2(this, action, DCET.OnceTimer, System.Delegate)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return timer.Id
    end
    GetOnceTimer = function (this, id)
      local default, timer = this.timers:TryGetValue(id)
      if not default then
        return nil
      end
      return System.as(timer, DCET.OnceTimer)
    end
    AddToTimeId = function (this, tillTime, id)
      this.TimeId:Add(tillTime, id)
      if tillTime < this.minTime then
        this.minTime = tillTime
      end
    end
    return {
      base = function (out)
        return {
          out.DCET.Entity
        }
      end,
      minTime = 0,
      Update = Update,
      WaitTillAsync = WaitTillAsync,
      WaitTillAsync1 = WaitTillAsync1,
      WaitAsync = WaitAsync,
      WaitAsync1 = WaitAsync1,
      NewRepeatedTimer = NewRepeatedTimer,
      GetRepeatedTimer = GetRepeatedTimer,
      Remove = Remove,
      NewOnceTimer = NewOnceTimer,
      GetOnceTimer = GetOnceTimer,
      AddToTimeId = AddToTimeId,
      __ctor__ = __ctor__
    }
  end)
end)
