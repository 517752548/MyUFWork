-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local DCET = DCET
local DCETRuntime = DCETRuntime
local MicrosoftIO = Microsoft.IO
local SystemNetSockets = System.Net.Sockets
local ListInt64 = System.List(System.Int64)
local DCET
local DictInt64TChannel
System.import(function (out)
  DCET = out.DCET
  DictInt64TChannel = System.Dictionary(System.Int64, DCET.TChannel)
end)
System.namespace("DCET", function (namespace)
  namespace.class("TService", function (namespace)
    local Dispose, OnComplete, AcceptAsync, OnAcceptComplete, GetChannel, ConnectChannel, ConnectChannel1, MarkNeedStartSend, 
    Remove, Update, internal, __ctor1__, __ctor2__
    internal = function (this)
      this.idChannels = DictInt64TChannel()
      this.innArgs = SystemNetSockets.SocketAsyncEventArgs()
      this.MemoryStreamManager = MicrosoftIO.RecyclableMemoryStreamManager()
      this.needStartSendChannel = ListInt64()
    end
    -- <summary>
    -- 即可做client也可做server
    -- </summary>
    __ctor1__ = function (this, packetSizeLength, ipEndPoint, acceptCallback)
      internal(this)
      System.base(this).__ctor__(this)
      this.PacketSizeLength = packetSizeLength
      this:addAcceptCallback(acceptCallback)

      this.acceptor = SystemNetSockets.Socket(SystemNetSockets.AddressFamily.InterNetwork, SystemNetSockets.SocketType.Stream, SystemNetSockets.ProtocolType.Tcp)
      this.acceptor:SetSocketOption(SystemNetSockets.SocketOptionLevel.Socket, SystemNetSockets.SocketOptionName.ReuseAddress, true)
      this.innArgs:addCompleted(System.fn(this, OnComplete))

      this.acceptor:Bind(ipEndPoint)
      this.acceptor:Listen(1000)

      AcceptAsync(this)
    end
    __ctor2__ = function (this, packetSizeLength)
      internal(this)
      System.base(this).__ctor__(this)
      this.PacketSizeLength = packetSizeLength
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      System.base(this).Dispose(this)

      for _, id in System.each(Linq.ToArray(this.idChannels:getKeys())) do
        local channel = this.idChannels:get(id)
        channel:Dispose()
      end

      local default = this.acceptor
      if default ~= nil then
        default:Close()
      end
      this.acceptor = nil
      this.innArgs:Dispose()
    end
    OnComplete = function (this, sender, e)
      repeat
        local default = e:getLastOperation()
        if default == SystemNetSockets.SocketAsyncOperation.Accept then
          DCETRuntime.OneThreadSynchronizationContext.getInstance():Post(System.fn(this, OnAcceptComplete), e)
          break
        else
          System.throw(System.Exception("socket accept error: " .. e:getLastOperation():EnumToString(SystemNetSockets.SocketAsyncOperation)))
        end
      until 1
    end
    AcceptAsync = function (this)
      this.innArgs:setAcceptSocket(nil)
      if this.acceptor:AcceptAsync(this.innArgs) then
        return
      end
      OnAcceptComplete(this, this.innArgs)
    end
    OnAcceptComplete = function (this, o)
      if this.acceptor == nil then
        return
      end
      local e = System.cast(SystemNetSockets.SocketAsyncEventArgs, o)

      if e:getSocketError() ~= SystemNetSockets.SocketError.Success then
        DCET.Log.Error("accept error " .. e:getSocketError():EnumToString(SystemNetSockets.SocketError))
        AcceptAsync(this)
        return
      end
      local channel = System.new(DCET.TChannel, 2, e:getAcceptSocket(), this)
      this.idChannels:set(channel.Id, channel)
      channel:setParent(this)

      System.try(function ()
        this:OnAccept(channel)
      end, function (default)
        local exception = default
        DCET.Log.Exception(exception)
      end)

      if this.acceptor == nil then
        return
      end

      AcceptAsync(this)
    end
    GetChannel = function (this, id)
      local channel = nil
      local _
      _, channel = this.idChannels:TryGetValue(id)
      return channel
    end
    ConnectChannel = function (this, ipEndPoint)
      local channel = DCET.TChannel(ipEndPoint, this)
      this.idChannels:set(channel.Id, channel)
      channel:setParent(this)
      return channel
    end
    ConnectChannel1 = function (this, address)
      local ipEndPoint = DCET.NetworkHelper.ToIPEndPoint1(address)
      return ConnectChannel(this, ipEndPoint)
    end
    MarkNeedStartSend = function (this, id)
      this.needStartSendChannel:Add(id)
    end
    Remove = function (this, id)
      local channel
      local default
      default, channel = this.idChannels:TryGetValue(id)
      if not default then
        return
      end
      if channel == nil then
        return
      end
      this.idChannels:RemoveKey(id)
      channel:Dispose()
    end
    Update = function (this)
      for _, id in System.each(this.needStartSendChannel) do
        local continue
        repeat
          local channel
          local default
          default, channel = this.idChannels:TryGetValue(id)
          if not default then
            continue = true
            break
          end

          if channel:getIsSending() then
            continue = true
            break
          end

          System.try(function ()
            channel:StartSend()
          end, function (default)
            local e = default
            DCET.Log.Exception(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.needStartSendChannel:Clear()
    end
    return {
      base = function (out)
        return {
          out.DCET.AService
        }
      end,
      PacketSizeLength = 0,
      Dispose = Dispose,
      AcceptAsync = AcceptAsync,
      GetChannel = GetChannel,
      ConnectChannel = ConnectChannel,
      ConnectChannel1 = ConnectChannel1,
      MarkNeedStartSend = MarkNeedStartSend,
      Remove = Remove,
      Update = Update,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
  end)
end)
