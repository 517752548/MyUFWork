-- Generated by CSharp.lua Compiler
local System = System
local DCET = DCET
local DCETRuntime = DCETRuntime
local SystemIO = System.IO
local SystemNetSockets = System.Net.Sockets
local SystemInteropServices = System.Runtime.InteropServices
local ArrayByte = System.Array(System.Byte)
local DCET
local QueueWaitSendBuffer
System.import(function (out)
  DCET = out.DCET
  QueueWaitSendBuffer = System.Queue(DCET.WaitSendBuffer)
end)
System.namespace("DCET", function (namespace)
  namespace.struct("WaitSendBuffer", function (namespace)
    local __ctor__
    __ctor__ = function (this, bytes, length)
      if length == nil then
        return
      end
      this.Bytes = bytes
      this.Length = length
    end
    return {
      Length = 0,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("KChannel", function (namespace)
    local getLocalConn, setLocalConn, Dispose, getStream, Disconnect, GetService, HandleConnnect, Accept, 
    Connect, Disconnect1, Update, HandleSend, HandleRecv, Output, SetOutput, KcpOutput, 
    KcpSend, Send1, Send, internal, __ctor1__, __ctor2__
    internal = function (this)
      this.kcp = System.default(System.IntPtr)
      this.sendBuffer = QueueWaitSendBuffer()
    end
    __ctor1__ = function (this, localConn, remoteConn, socket, remoteEndPoint, kService)
      internal(this)
      DCET.AChannel.__ctor__(this, kService, DCET.ChannelType.Accept)
      this.memoryStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])

      setLocalConn(this, localConn)
      this.RemoteConn = remoteConn
      this.remoteEndPoint = remoteEndPoint
      this.socket = socket
      this.kcp = DCETRuntime.Kcp.KcpCreate(this.RemoteConn, System.IntPtr(getLocalConn(this)))

      SetOutput(this)
      DCETRuntime.Kcp.KcpNodelay(this.kcp, 1, 10, 1, 1)
      DCETRuntime.Kcp.KcpWndsize(this.kcp, 256, 256)
      DCETRuntime.Kcp.KcpSetmtu(this.kcp, 470)
      this.lastRecvTime = kService.TimeNow
      this.createTime = kService.TimeNow
      Accept(this)
    end
    __ctor2__ = function (this, localConn, socket, remoteEndPoint, kService)
      internal(this)
      DCET.AChannel.__ctor__(this, kService, DCET.ChannelType.Connect)
      this.memoryStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])

      setLocalConn(this, localConn)
      this.socket = socket
      this.remoteEndPoint = remoteEndPoint
      this.lastRecvTime = kService.TimeNow
      this.createTime = kService.TimeNow
      Connect(this)
    end
    getLocalConn = function (this)
      return System.toUInt32(this.Id)
    end
    setLocalConn = function (this, value)
      this.Id = value
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      DCET.AChannel.Dispose(this)

      System.try(function ()
        if this.Error == 0 --[[ErrorCode.ERR_Success]] then
          for i = 0, 3 do
            Disconnect1(this)
          end
        end
      end, function (default)
        -- ignored
      end)

      if this.kcp ~= System.IntPtr.Zero then
        DCETRuntime.Kcp.KcpRelease(this.kcp)
        this.kcp = System.IntPtr.Zero
      end
      this.socket = nil
      this.memoryStream:Dispose()
    end
    getStream = function (this)
      return this.memoryStream
    end
    Disconnect = function (this, error)
      this:OnError(error)
    end
    GetService = function (this)
      return System.cast(DCET.KService, this.Service)
    end
    HandleConnnect = function (this, remoteConn)
      if this.isConnected then
        return
      end

      this.RemoteConn = remoteConn

      this.kcp = DCETRuntime.Kcp.KcpCreate(this.RemoteConn, System.IntPtr(getLocalConn(this)))
      SetOutput(this)
      DCETRuntime.Kcp.KcpNodelay(this.kcp, 1, 10, 1, 1)
      DCETRuntime.Kcp.KcpWndsize(this.kcp, 256, 256)
      DCETRuntime.Kcp.KcpSetmtu(this.kcp, 470)

      this.isConnected = true
      this.lastRecvTime = GetService(this).TimeNow

      HandleSend(this)
    end
    Accept = function (this)
      if this.socket == nil then
        return
      end

      local timeNow = GetService(this).TimeNow

      System.try(function ()
        DCETRuntime.StreamHelper.WriteToByte(this.memoryStream, 0, 2 --[[KcpProtocalType.ACK]])
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 1, getLocalConn(this))
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 5, this.RemoteConn)
        this.socket:SendTo(this.memoryStream:GetBuffer(), 0, 9, SystemNetSockets.SocketFlags.None, this.remoteEndPoint)

        -- 200毫秒后再次update发送connect请求
        GetService(this):AddToUpdateNextTime(timeNow + 200, this.Id)
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
        this:OnError(102009 --[[ErrorCode.ERR_SocketCantSend]])
      end)
    end
    -- <summary>
    -- 发送请求连接消息
    -- </summary>
    Connect = function (this)
      System.try(function ()
        local timeNow = GetService(this).TimeNow

        this.lastRecvTime = timeNow

        DCETRuntime.StreamHelper.WriteToByte(this.memoryStream, 0, 1 --[[KcpProtocalType.SYN]])
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 1, getLocalConn(this))
        this.socket:SendTo(this.memoryStream:GetBuffer(), 0, 5, SystemNetSockets.SocketFlags.None, this.remoteEndPoint)

        -- 200毫秒后再次update发送connect请求
        GetService(this):AddToUpdateNextTime(timeNow + 300, this.Id)
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
        this:OnError(102009 --[[ErrorCode.ERR_SocketCantSend]])
      end)
    end
    Disconnect1 = function (this)
      if this.socket == nil then
        return
      end
      System.try(function ()
        DCETRuntime.StreamHelper.WriteToByte(this.memoryStream, 0, 3 --[[KcpProtocalType.FIN]])
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 1, getLocalConn(this))
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 5, this.RemoteConn)
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 9, System.toUInt32(this.Error))
        this.socket:SendTo(this.memoryStream:GetBuffer(), 0, 13, SystemNetSockets.SocketFlags.None, this.remoteEndPoint)
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
        this:OnError(102009 --[[ErrorCode.ERR_SocketCantSend]])
      end)
    end
    Update = function (this)
      if this:getIsDisposed() then
        return
      end

      local timeNow = GetService(this).TimeNow

      -- 如果还没连接上，发送连接请求
      if not this.isConnected then
        -- 10秒没连接上则报错
        if timeNow - this.createTime > 10000 --[[10 * 1000]] then
          this:OnError(102005 --[[ErrorCode.ERR_KcpCantConnect]])
          return
        end

        if timeNow - this.lastRecvTime < 500 then
          return
        end

        repeat
          local default = this.ChannelType
          if default == DCET.ChannelType.Accept then
            Accept(this)
            break
          elseif default == DCET.ChannelType.Connect then
            Connect(this)
            break
          end
        until 1

        return
      end

      -- 超时断开连接
      --if (timeNow - this.lastRecvTime > 40 * 1000)
      --{
      --	this.OnError(ErrorCode.ERR_KcpChannelTimeout);
      --	return;
      --}

      local default = System.try(function ()
        DCETRuntime.Kcp.KcpUpdate(this.kcp, timeNow)
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
        this:OnError(102010 --[[ErrorCode.ERR_SocketError]])
        return true
      end)
      if default then
        return
      end


      if this.kcp ~= System.IntPtr.Zero then
        local nextUpdateTime = DCETRuntime.Kcp.KcpCheck(this.kcp, timeNow)
        GetService(this):AddToUpdateNextTime(nextUpdateTime, this.Id)
      end
    end
    HandleSend = function (this)
      while true do
        if #this.sendBuffer <= 0 then
          break
        end

        local buffer = this.sendBuffer:Dequeue()
        KcpSend(this, buffer.Bytes, buffer.Length)
      end
    end
    HandleRecv = function (this, date, offset, length)
      if this:getIsDisposed() then
        return
      end

      this.isConnected = true

      DCETRuntime.Kcp.KcpInput(this.kcp, date, offset, length)
      GetService(this):AddToUpdateNextTime(0, this.Id)

      while true do
        if this:getIsDisposed() then
          return
        end
        local n = DCETRuntime.Kcp.KcpPeeksize(this.kcp)
        if n < 0 then
          return
        end
        if n == 0 then
          this:OnError(10052 --[[(int)SocketError.NetworkReset]])
          return
        end

        local buffer = this.memoryStream:GetBuffer()
        this.memoryStream:SetLength(n)
        this.memoryStream:Seek(0, SystemIO.SeekOrigin.Begin)
        local count = DCETRuntime.Kcp.KcpRecv(this.kcp, buffer, 65535 --[[UInt16.MaxValue]])
        if n ~= count then
          return
        end
        if count <= 0 then
          return
        end

        this.lastRecvTime = GetService(this).TimeNow

        this:OnRead(this.memoryStream)
      end
    end
    Output = function (this, bytes, count)
      if this:getIsDisposed() then
        return
      end
      local default = System.try(function ()
        if count == 0 then
          DCET.Log.Error("output 0" .. "")
          return true
        end

        DCETRuntime.StreamHelper.WriteToByte(this.memoryStream, 0, 4 --[[KcpProtocalType.MSG]])
        -- 每个消息头部写下该channel的id;
        DCETRuntime.StreamHelper.WriteToUint(this.memoryStream, 1, getLocalConn(this))
        SystemInteropServices.Marshal.Copy(bytes, this.memoryStream:GetBuffer(), 5, count)
        this.socket:SendTo(this.memoryStream:GetBuffer(), 0, count + 5, SystemNetSockets.SocketFlags.None, this.remoteEndPoint)
      end, function (default)
        local e = default
        DCET.Log.Exception(e)
        this:OnError(102009 --[[ErrorCode.ERR_SocketCantSend]])
      end)
      if default then
        return
      end
    end
    SetOutput = function (this)
      -- 跟上一行一样写法，pc跟linux会出错, 保存防止被GC
      this.kcpOutput = KcpOutput
      DCETRuntime.Kcp.KcpSetoutput(this.kcp, this.kcpOutput)
    end
    KcpOutput = function (bytes, len, kcp, user)
      DCET.KService.Output(bytes, len, user)
      return len
    end
    KcpSend = function (this, buffers, length)
      if this:getIsDisposed() then
        return
      end
      DCETRuntime.Kcp.KcpSend(this.kcp, buffers, length)
      GetService(this):AddToUpdateNextTime(0, this.Id)
    end
    Send1 = function (this, buffer, index, length)
      if this.isConnected then
        KcpSend(this, buffer, length)
        return
      end

      this.sendBuffer:Enqueue(DCET.WaitSendBuffer(buffer, length))
    end
    Send = function (this, stream)
      if this.kcp ~= System.IntPtr.Zero then
        -- 检查等待发送的消息，如果超出两倍窗口大小，应该断开连接
        if DCETRuntime.Kcp.KcpWaitsnd(this.kcp) > 512 --[[256 * 2]] then
          this:OnError(102011 --[[ErrorCode.ERR_KcpWaitSendSizeTooLarge]])
          return
        end
      end

      local size = System.toUInt16(stream:getLength() - stream:getPosition())
      local bytes
      if this.isConnected then
        bytes = stream:GetBuffer()
      else
        bytes = ArrayByte:new(size)
        System.Array.Copy(stream:GetBuffer(), stream:getPosition(), bytes, 0, size)
      end

      Send1(this, bytes, 0, size)
    end
    return {
      base = function (out)
        return {
          out.DCET.AChannel
        }
      end,
      isConnected = false,
      lastRecvTime = 0,
      createTime = 0,
      RemoteConn = 0,
      getLocalConn = getLocalConn,
      setLocalConn = setLocalConn,
      Dispose = Dispose,
      getStream = getStream,
      Disconnect = Disconnect,
      HandleConnnect = HandleConnnect,
      Accept = Accept,
      Update = Update,
      HandleRecv = HandleRecv,
      Output = Output,
      SetOutput = SetOutput,
      KcpOutput = KcpOutput,
      Send = Send,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
  end)
end)
