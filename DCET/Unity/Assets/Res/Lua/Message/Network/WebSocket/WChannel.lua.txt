-- Generated by CSharp.lua Compiler
local System = System
local DCET = DCET
local SystemNetWebSockets = System.Net.WebSockets
local ArrayByte = System.Array(System.Byte)
local QueueArrayByte = System.Queue(ArrayByte)
local ArraySegmentByte = System.ArraySegment(System.Byte)
local DCET
System.import(function (out)
  DCET = out.DCET
end)
System.namespace("DCET", function (namespace)
  namespace.class("WChannel", function (namespace)
    local Dispose, getStream, Start, GetService, ConnectAsync, Send, StartSend, StartRecv, 
    internal, __ctor1__, __ctor2__
    internal = function (this)
      this.queue = QueueArrayByte()
      this.cancellationTokenSource = System.CancellationTokenSource()
    end
    __ctor1__ = function (this, webSocketContext, service)
      internal(this)
      DCET.AChannel.__ctor__(this, service, DCET.ChannelType.Accept)
      this.WebSocketContext = webSocketContext

      this.webSocket = webSocketContext:getWebSocket()

      this.memoryStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])
      this.recvStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])

      this.isConnected = true
    end
    __ctor2__ = function (this, webSocket, service)
      internal(this)
      DCET.AChannel.__ctor__(this, service, DCET.ChannelType.Connect)
      this.webSocket = webSocket

      this.memoryStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])
      this.recvStream = GetService(this).MemoryStreamManager:GetStream("message", 65535 --[[UInt16.MaxValue]])

      this.isConnected = false
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      DCET.AChannel.Dispose(this)

      this.cancellationTokenSource:Cancel()
      this.cancellationTokenSource:Dispose()
      this.cancellationTokenSource = nil

      this.webSocket:Dispose()

      this.memoryStream:Dispose()
    end
    getStream = function (this)
      return this.memoryStream
    end
    Start = function (this)
      if not this.isConnected then
        return
      end

      StartRecv(this)
      StartSend(this)
    end
    GetService = function (this)
      return System.cast(DCET.WService, this.Service)
    end
    ConnectAsync = function (this, url)
      System.async(function (async, this, url)
        System.try(function ()
          async:await((System.cast(SystemNetWebSockets.ClientWebSocket, this.webSocket)):ConnectAsync(System.Uri(url), this.cancellationTokenSource:getToken()))
          this.isConnected = true
          this:Start()
        end, function (default)
          local e = default
          DCET.Log.Exception(e)
          this:OnError(103004 --[[ErrorCode.ERR_WebsocketConnectError]])
        end)
      end, true, this, url)
    end
    Send = function (this, stream)
      local bytes = ArrayByte:new(stream:getLength())
      System.Array.Copy(stream:GetBuffer(), bytes, #bytes)
      this.queue:Enqueue(bytes)

      if this.isConnected then
        StartSend(this)
      end
    end
    StartSend = function (this)
      System.async(function (async, this)
        if this:getIsDisposed() then
          return
        end

        local default = System.try(function ()
          if this.isSending then
            return true
          end

          this.isSending = true

          while true do
            if #this.queue == 0 then
              this.isSending = false
              return true
            end

            local bytes = this.queue:Dequeue()
            local default = System.try(function ()
              async:await(this.webSocket:SendAsync(ArraySegmentByte(bytes, 0, #bytes), SystemNetWebSockets.WebSocketMessageType.Binary, true, this.cancellationTokenSource:getToken()))
              if this:getIsDisposed() then
                return true
              end
            end, function (default)
              local e = default
              DCET.Log.Exception(e)
              this:OnError(103005 --[[ErrorCode.ERR_WebsocketSendError]])
              return true
            end)
            if default then
              return true
            end
          end
        end, function (default)
          local e = default
          DCET.Log.Exception(e)
        end)
        if default then
          return
        end
      end, true, this)
    end
    StartRecv = function (this)
      System.async(function (async, this)
        if this:getIsDisposed() then
          return
        end

        local default = System.try(function ()
          while true do
            local receiveResult

            local receiveCount = 0
            repeat
              receiveResult = async:await(this.webSocket:ReceiveAsync(ArraySegmentByte(this.recvStream:GetBuffer(), receiveCount, this.recvStream:getCapacity() - receiveCount), this.cancellationTokenSource:getToken()))

              if this:getIsDisposed() then
                return true
              end

              receiveCount = receiveCount + receiveResult:getCount()
            until not not receiveResult:getEndOfMessage()

            if receiveResult:getMessageType() == SystemNetWebSockets.WebSocketMessageType.Close then
              this:OnError(103001 --[[ErrorCode.ERR_WebsocketPeerReset]])
              return true
            end

            if receiveResult:getCount() > 65535 --[[UInt16.MaxValue]] then
              async:await(this.webSocket:CloseAsync(SystemNetWebSockets.WebSocketCloseStatus.MessageTooBig, "message too big: " .. receiveResult:getCount(), this.cancellationTokenSource:getToken()))
              this:OnError(103002 --[[ErrorCode.ERR_WebsocketMessageTooBig]])
              return true
            end

            this.recvStream:SetLength(receiveResult:getCount())
            this:OnRead(this.recvStream)
          end
        end, function (default)
          local e = default
          DCET.Log.Exception(e)
          this:OnError(103006 --[[ErrorCode.ERR_WebsocketRecvError]])
        end)
        if default then
          return
        end
      end, true, this)
    end
    return {
      base = function (out)
        return {
          out.DCET.AChannel
        }
      end,
      isSending = false,
      isConnected = false,
      Dispose = Dispose,
      getStream = getStream,
      Start = Start,
      ConnectAsync = ConnectAsync,
      Send = Send,
      StartSend = StartSend,
      StartRecv = StartRecv,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
  end)
end)
