-- Generated by CSharp.lua Compiler
local System = System
local SystemIO = System.IO
local QueueString = System.Queue(System.String)
local HashSetString = System.HashSet(System.String)
local ET
local ListUnityWebRequestAsync
System.import(function (out)
  ET = out.ET
  ListUnityWebRequestAsync = System.List(ET.UnityWebRequestAsync)
end)
System.namespace("ET", function (namespace)
  namespace.class("BundleDownloaderComponentAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      self.bundles = QueueString()
      self.downloadedBundles = HashSetString()
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_1(out.ET.BundleDownloaderComponent)
        }
      end,
      Awake = Awake
    }
  end)

  -- <summary>
  -- 用来对比web端的资源，比较md5，对比下载资源
  -- </summary>
  namespace.class("BundleDownloaderComponent", function (namespace)
    local Dispose, StartAsync, getProgress, DownloadAsync, class, __ctor__
    __ctor__ = function (this)
      this.webRequests = ListUnityWebRequestAsync()
      ET.Entity.__ctor__(this)
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      if this:getParent():getIsDisposed() then
        return
      end

      ET.Entity.Dispose(this)

      this.remoteVersionConfig = nil
      this.TotalSize = 0
      this.bundles = nil
      this.downloadedBundles = nil
      for _, webRequest in System.each(this.webRequests) do
        webRequest:Dispose()
      end
      this.webRequests:Clear()

      this:getParent():RemoveComponent(class)
    end
    StartAsync = function (this, url)
      return System.async(function (async, this, url)
        -- 获取远程的Version.txt
        local versionUrl = ""
        System.try(function ()
          System.using(ET.EntityFactory.Create1(this:getDomain(), ET.UnityWebRequestAsync), function (webRequestAsync)
            versionUrl = url .. "StreamingAssets/" .. "Version.txt"
            --Log.Debug(versionUrl);
            async:Await(webRequestAsync:DownloadAsync(versionUrl))
            this.remoteVersionConfig = ET.JsonHelper.FromJson(webRequestAsync.Request:getdownloadHandler():gettext(), ET.VersionConfig)
            --Log.Debug(JsonHelper.ToJson(this.VersionConfig));
          end)
        end, function (default)
          local e = default
          System.throw(System.Exception("url: " .. versionUrl, e))
        end)

        -- 获取streaming目录的Version.txt
        local streamingVersionConfig
        local versionPath = SystemIO.Path.Combine(ET.PathHelper.getAppResPath4Web(), "Version.txt")
        System.using(ET.EntityFactory.Create1(this:getDomain(), ET.UnityWebRequestAsync), function (request)
          async:Await(request:DownloadAsync(versionPath))
          streamingVersionConfig = ET.JsonHelper.FromJson(request.Request:getdownloadHandler():gettext(), ET.VersionConfig)
        end)

        -- 删掉远程不存在的文件
        local directoryInfo = SystemIO.DirectoryInfo(ET.PathHelper.getAppHotfixResPath())
        if directoryInfo:getExists() then
          local fileInfos = directoryInfo:GetFiles()
          for _, fileInfo in System.each(fileInfos) do
            local continue
            repeat
              if this.remoteVersionConfig.FileInfoDict:ContainsKey(fileInfo:getName()) then
                continue = true
                break
              end

              if fileInfo:getName() == "Version.txt" then
                continue = true
                break
              end

              fileInfo:Delete()
              continue = true
            until 1
            if not continue then
              break
            end
          end
        else
          directoryInfo:Create()
        end

        -- 对比MD5
        for _, fileVersionInfo in System.each(this.remoteVersionConfig.FileInfoDict:getValues()) do
          local continue
          repeat
            -- 对比md5
            local localFileMD5 = ET.BundleHelper.GetBundleMD5(streamingVersionConfig, fileVersionInfo.File)
            if fileVersionInfo.MD5 == localFileMD5 then
              continue = true
              break
            end
            this.bundles:Enqueue(fileVersionInfo.File)
            this.TotalSize = this.TotalSize + fileVersionInfo.Size
            continue = true
          until 1
          if not continue then
            break
          end
        end
      end, nil, this, url)
    end
    getProgress = function (this)
      if this.TotalSize == 0 then
        return 0
      end

      local alreadyDownloadBytes = 0
      --已经下载完成的
      for _, downloadedBundle in System.each(this.downloadedBundles) do
        alreadyDownloadBytes = alreadyDownloadBytes + this.remoteVersionConfig.FileInfoDict:get(downloadedBundle).Size
      end
      --当前正在下载的
      for _, webRequest in System.each(this.webRequests) do
        alreadyDownloadBytes = alreadyDownloadBytes + System.toInt64(webRequest.Request:getdownloadedBytes())
      end
      return System.ToInt32(alreadyDownloadBytes * 100 / this.TotalSize)
    end
    DownloadAsync = function (this, url)
      return System.async(function (async, this, url)
        if #this.bundles == 0 then
          return
        end
        System.try(function ()
          local downloadFile
          --正在下载的文件个数
          local downloadingCount = 0
          --下载单个文件
          downloadFile = function ()
            System.async(function (async)
              if #this.bundles == 0 then
                return
              end
              downloadingCount = downloadingCount + 1
              --取出一个进行下载
              local downloading = this.bundles:Dequeue()
              ET.Log.Debug("开始下载(" .. downloadingCount .. "):" .. downloading)
              System.try(function ()
                System.using(ET.EntityFactory.Create1(this:getDomain(), ET.UnityWebRequestAsync), function (webRequest)
                  this.webRequests:Add(webRequest)
                  async:Await(webRequest:DownloadAsync(url .. "StreamingAssets/" .. downloading))
                  local data = webRequest.Request:getdownloadHandler():getdata()
                  this.webRequests:Remove(webRequest)
                  local path = SystemIO.Path.Combine(ET.PathHelper.getAppHotfixResPath(), downloading)
                  System.using(SystemIO.FileStream(path, SystemIO.FileMode.Create), function (fs)
                    fs:Write(data, 0, #data)
                  end)
                end)
              end, function (default)
                local e = default
                --下载异常跳过
                ET.Log.Error("download bundle error: " .. downloading .. "\n" .. System.toString(e))
              end, function ()
                downloadingCount = downloadingCount - 1
              end)
              --正常下载
              this.downloadedBundles:Add(downloading)
              ET.Log.Debug("download bundle Finish: " .. downloading .. "\n")
            end, true)
          end
          --[[
                //最多同时下载n个文件 下载40M(400~500)个文件测试时间(ms)对比
                //等待n个任务同时完成再继续 1~61616 2~44796 3~34377 4~31918 5~27184 6~25564 7~22817 8~22719
                //完成1个补充1个最大n个任务 1~61309 8~11871 9~10843 10~10600 15~9309 20~9146 100~9195
                ]]

          --最大任务数量20 速度从61秒提升到9秒
          local maxCount = 20
          while true do
            async:Await(ET.TimerComponent.Instance:WaitAsync1(10))
            --需要下载队列取完 正在下载为0表示完成更新
            if #this.bundles == 0 and downloadingCount == 0 then
              break
            end
            for i = downloadingCount, maxCount - 1 do
              downloadFile()
            end
          end
        end, function (default)
          local e = default
          ET.Log.Error1(e)
        end)
      end, nil, this, url)
    end
    class = {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      TotalSize = 0,
      Dispose = Dispose,
      StartAsync = StartAsync,
      getProgress = getProgress,
      DownloadAsync = DownloadAsync,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
