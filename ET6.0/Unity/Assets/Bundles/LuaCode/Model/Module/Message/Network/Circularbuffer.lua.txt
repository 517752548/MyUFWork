-- Generated by CSharp.lua Compiler
local System = System
local SystemIO = System.IO
local ArrayByte = System.Array(System.Byte)
local QueueArrayByte = System.Queue(ArrayByte)
local ET
System.import(function (out)
  ET = out.ET
end)
System.namespace("ET", function (namespace)
  namespace.class("CircularBuffer", function (namespace)
    local getLength, AddLast, RemoveFirst, getFirst, getLast, ReadAsync3, Read2, Write2, 
    WriteAsync3, Read, Write, Flush, Seek, SetLength, getCanRead, getCanSeek, 
    getCanWrite, getPosition, setPosition, __ctor__
    __ctor__ = function (this)
      this.bufferQueue = QueueArrayByte()
      this.bufferCache = QueueArrayByte()
      SystemIO.Stream.__ctor__(this)
      AddLast(this)
    end
    getLength = function (this)
      local c = 0
      if #this.bufferQueue == 0 then
        c = 0
      else
        c = (#this.bufferQueue - 1) * this.ChunkSize + this.LastIndex - this.FirstIndex
      end
      if c < 0 then
        ET.Log.Error(ET.StringHelper.Fmt("CircularBuffer count < 0: {0}, {1}, {2}", System.Array(System.Object)(#this.bufferQueue, this.LastIndex, this.FirstIndex)))
      end
      return c
    end
    AddLast = function (this)
      local buffer
      if #this.bufferCache > 0 then
        buffer = this.bufferCache:Dequeue()
      else
        buffer = ArrayByte:new(this.ChunkSize)
      end
      this.bufferQueue:Enqueue(buffer)
      this.lastBuffer = buffer
    end
    RemoveFirst = function (this)
      this.bufferCache:Enqueue(this.bufferQueue:Dequeue())
    end
    getFirst = function (this)
      if #this.bufferQueue == 0 then
        AddLast(this)
      end
      return this.bufferQueue:Peek()
    end
    getLast = function (this)
      if #this.bufferQueue == 0 then
        AddLast(this)
      end
      return this.lastBuffer
    end
    -- <summary>
    -- 从CircularBuffer读到stream中
    -- </summary>
    -- <returns></returns>
    ReadAsync3 = function (this, stream)
      return System.async(function (async, this, stream)
        local buffLength = this:getLength()
        local sendSize = this.ChunkSize - this.FirstIndex
        if sendSize > buffLength then
          sendSize = System.toInt32(buffLength)
        end

        async:await(stream:WriteAsync(getFirst(this), this.FirstIndex, sendSize))

        this.FirstIndex = this.FirstIndex + sendSize
        if this.FirstIndex == this.ChunkSize then
          this.FirstIndex = 0
          RemoveFirst(this)
        end
      end, nil, this, stream)
    end
    Read2 = function (this, stream, count)
      if count > this:getLength() then
        System.throw(System.Exception("bufferList length < count, " .. this:getLength() .. " " .. count))
      end

      local alreadyCopyCount = 0
      while alreadyCopyCount < count do
        local n = count - alreadyCopyCount
        if this.ChunkSize - this.FirstIndex > n then
          stream:Write(getFirst(this), this.FirstIndex, n)
          this.FirstIndex = this.FirstIndex + n
          alreadyCopyCount = alreadyCopyCount + n
        else
          stream:Write(getFirst(this), this.FirstIndex, this.ChunkSize - this.FirstIndex)
          alreadyCopyCount = alreadyCopyCount + (this.ChunkSize - this.FirstIndex)
          this.FirstIndex = 0
          RemoveFirst(this)
        end
      end
    end
    Write2 = function (this, stream)
      local count = System.toInt32(stream:getLength() - stream:getPosition())

      local alreadyCopyCount = 0
      while alreadyCopyCount < count do
        if this.LastIndex == this.ChunkSize then
          AddLast(this)
          this.LastIndex = 0
        end

        local n = count - alreadyCopyCount
        if this.ChunkSize - this.LastIndex > n then
          stream:Read(this.lastBuffer, this.LastIndex, n)
          this.LastIndex = this.LastIndex + (count - alreadyCopyCount)
          alreadyCopyCount = alreadyCopyCount + n
        else
          stream:Read(this.lastBuffer, this.LastIndex, this.ChunkSize - this.LastIndex)
          alreadyCopyCount = alreadyCopyCount + (this.ChunkSize - this.LastIndex)
          this.LastIndex = this.ChunkSize
        end
      end
    end
    -- <summary>
    -- 从stream写入CircularBuffer
    -- </summary>
    -- <returns></returns>
    WriteAsync3 = function (this, stream)
      return System.async(function (async, this, stream)
        local size = this.ChunkSize - this.LastIndex

        local n = async:await(stream:ReadAsync(getLast(this), this.LastIndex, size))

        if n == 0 then
          return 0
        end

        this.LastIndex = this.LastIndex + n

        if this.LastIndex == this.ChunkSize then
          AddLast(this)
          this.LastIndex = 0
        end

        return n
      end, nil, this, stream)
    end
    Read = function (this, buffer, offset, count)
      if #buffer < offset + count then
        System.throw(System.Exception("bufferList length < coutn, buffer length: " .. #buffer .. " " .. offset .. " " .. count))
      end

      local length = this:getLength()
      if length < count then
        count = System.toInt32(length)
      end

      local alreadyCopyCount = 0
      while alreadyCopyCount < count do
        local n = count - alreadyCopyCount
        if this.ChunkSize - this.FirstIndex > n then
          System.Array.Copy(getFirst(this), this.FirstIndex, buffer, alreadyCopyCount + offset, n)
          this.FirstIndex = this.FirstIndex + n
          alreadyCopyCount = alreadyCopyCount + n
        else
          System.Array.Copy(getFirst(this), this.FirstIndex, buffer, alreadyCopyCount + offset, this.ChunkSize - this.FirstIndex)
          alreadyCopyCount = alreadyCopyCount + (this.ChunkSize - this.FirstIndex)
          this.FirstIndex = 0
          RemoveFirst(this)
        end
      end

      return count
    end
    Write = function (this, buffer, offset, count)
      local alreadyCopyCount = 0
      while alreadyCopyCount < count do
        if this.LastIndex == this.ChunkSize then
          AddLast(this)
          this.LastIndex = 0
        end

        local n = count - alreadyCopyCount
        if this.ChunkSize - this.LastIndex > n then
          System.Array.Copy(buffer, alreadyCopyCount + offset, this.lastBuffer, this.LastIndex, n)
          this.LastIndex = this.LastIndex + (count - alreadyCopyCount)
          alreadyCopyCount = alreadyCopyCount + n
        else
          System.Array.Copy(buffer, alreadyCopyCount + offset, this.lastBuffer, this.LastIndex, this.ChunkSize - this.LastIndex)
          alreadyCopyCount = alreadyCopyCount + (this.ChunkSize - this.LastIndex)
          this.LastIndex = this.ChunkSize
        end
      end
    end
    Flush = function (this)
      System.throw(System.NotImplementedException())
    end
    Seek = function (this, offset, origin)
      System.throw(System.NotImplementedException())
    end
    SetLength = function (this, value)
      System.throw(System.NotImplementedException())
    end
    getCanRead = function (this)
      return true
    end
    getCanSeek = function (this)
      return false
    end
    getCanWrite = function (this)
      return true
    end
    getPosition, setPosition = System.property("Position1")
    return {
      base = function (out)
        return {
          System.IO.Stream
        }
      end,
      ChunkSize = 8192,
      LastIndex = 0,
      FirstIndex = 0,
      getLength = getLength,
      AddLast = AddLast,
      RemoveFirst = RemoveFirst,
      getFirst = getFirst,
      getLast = getLast,
      ReadAsync3 = ReadAsync3,
      Read2 = Read2,
      Write2 = Write2,
      WriteAsync3 = WriteAsync3,
      Read = Read,
      Write = Write,
      Flush = Flush,
      Seek = Seek,
      SetLength = SetLength,
      getCanRead = getCanRead,
      getCanSeek = getCanSeek,
      getCanWrite = getCanWrite,
      Position1 = 0,
      getPosition = getPosition,
      setPosition = setPosition,
      __ctor__ = __ctor__
    }
  end)
end)
