-- Generated by CSharp.lua Compiler
local System = System
local QueueInt64 = System.Queue(System.Int64)
local ET
local DictInt64ITimer
local MultiMap_2Int64Int64
local ETTaskCompletionSource_1Boolean
System.import(function (out)
  ET = out.ET
  DictInt64ITimer = System.Dictionary(System.Int64, ET.ITimer)
  MultiMap_2Int64Int64 = ET.MultiMap_2(System.Int64, System.Int64)
  ETTaskCompletionSource_1Boolean = ET.ETTaskCompletionSource_1(System.Boolean)
end)
System.namespace("ET", function (namespace)
  namespace.interface("ITimer", function ()
    return {}
  end)


  namespace.class("OnceWaitTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, callback)
      self.Callback = callback
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_2(out.ET.OnceWaitTimer, out.ET.ETTaskCompletionSource_1(System.Boolean))
        }
      end,
      Awake = Awake
    }
  end)

  namespace.class("OnceWaitTimer", function (namespace)
    local Run, __ctor__
    __ctor__ = function (this)
      ET.Entity.__ctor__(this)
    end
    Run = function (this, isTimeout)
      local tcs = this.Callback
      this:GetParent(ET.TimerComponent):Remove(this.Id)
      tcs:SetResult(isTimeout)
    end
    return {
      base = function (out)
        return {
          out.ET.Entity,
          out.ET.ITimer
        }
      end,
      Run = Run,
      __ctor__ = __ctor__
    }
  end)


  namespace.class("OnceTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, callback)
      self.Callback = callback
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_2(out.ET.OnceTimer, System.Delegate)
        }
      end,
      Awake = Awake
    }
  end)

  namespace.class("OnceTimer", function (namespace)
    local Run, __ctor__
    __ctor__ = function (this)
      ET.Entity.__ctor__(this)
    end
    Run = function (this, isTimeout)
      System.try(function ()
        this.Callback(isTimeout)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)
    end
    return {
      base = function (out)
        return {
          out.ET.Entity,
          out.ET.ITimer
        }
      end,
      Run = Run,
      __ctor__ = __ctor__
    }
  end)


  namespace.class("RepeatedTimerAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, repeatedTime, callback)
      self:Awake(repeatedTime, callback)
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_3(out.ET.RepeatedTimer, System.Int64, System.Delegate)
        }
      end,
      Awake = Awake
    }
  end)

  namespace.class("RepeatedTimer", function (namespace)
    local Awake, Run, Dispose, __ctor__
    __ctor__ = function (this)
      ET.Entity.__ctor__(this)
    end
    Awake = function (this, repeatedTime, callback)
      this.StartTime = ET.TimeHelper.Now()
      this.RepeatedTime = repeatedTime
      this.Callback = callback
      this.Count = 1
    end
    Run = function (this, isTimeout)
      this.Count = this.Count + 1
      local timerComponent = this:GetParent(ET.TimerComponent)
      local tillTime = this.StartTime + this.RepeatedTime * this.Count
      timerComponent:AddToTimeId(tillTime, this.Id)

      System.try(function ()
        local default = this.Callback
        if default ~= nil then
          default(isTimeout)
        end
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      local id = this.Id

      if id == 0 then
        ET.Log.Error("RepeatedTimer可能多次释放了" .. "")
        return
      end

      ET.Entity.Dispose(this)

      this.StartTime = 0
      this.RepeatedTime = 0
      this.Callback = nil
      this.Count = 0
    end
    return {
      base = function (out)
        return {
          out.ET.Entity,
          out.ET.ITimer
        }
      end,
      Awake = Awake,
      StartTime = 0,
      RepeatedTime = 0,
      Count = 0,
      Run = Run,
      Dispose = Dispose,
      __ctor__ = __ctor__
    }
  end)


  namespace.class("TimerComponentAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      ET.TimerComponent.Instance = self
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_1(out.ET.TimerComponent)
        }
      end,
      Awake = Awake
    }
  end)


  namespace.class("TimerComponentUpdateSystem", function (namespace)
    local Update
    Update = function (this, self)
      self:Update()
    end
    return {
      base = function (out)
        return {
          out.ET.UpdateSystem_1(out.ET.TimerComponent)
        }
      end,
      Update = Update
    }
  end)

  namespace.class("TimerComponent", function (namespace)
    local Update, WaitTillAsync, WaitTillAsync1, WaitAsync, WaitAsync1, NewRepeatedTimer, GetRepeatedTimer, Remove, 
    NewOnceTimer, GetOnceTimer, AddToTimeId, __ctor__
    __ctor__ = function (this)
      this.timers = DictInt64ITimer()
      this.TimeId = MultiMap_2Int64Int64()
      this.timeOutTime = QueueInt64()
      this.timeOutTimerIds = QueueInt64()
      ET.Entity.__ctor__(this)
    end
    Update = function (this)
      if this.TimeId:getCount() == 0 then
        return
      end

      local timeNow = ET.TimeHelper.Now()

      if timeNow < this.minTime then
        return
      end

      for _, kv in System.each(this.TimeId:GetDictionary()) do
        local k = kv.Key
        if k > timeNow then
          this.minTime = k
          break
        end
        this.timeOutTime:Enqueue(k)
      end

      while #this.timeOutTime > 0 do
        local time = this.timeOutTime:Dequeue()
        for _, timerId in System.each(this.TimeId:get(time)) do
          this.timeOutTimerIds:Enqueue(timerId)
        end
        this.TimeId:Remove1(time)
      end

      while #this.timeOutTimerIds > 0 do
        local continue
        repeat
          local timerId = this.timeOutTimerIds:Dequeue()
          local timer
          local default
          default, timer = this.timers:TryGetValue(timerId)
          if not default then
            continue = true
            break
          end

          timer:Run(true)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    WaitTillAsync = function (this, tillTime, cancellationToken)
      return System.async(function (async, this, tillTime, cancellationToken)
        if ET.TimeHelper.Now() > tillTime then
          return true
        end
        local tcs = ETTaskCompletionSource_1Boolean()
        local timer = ET.EntityFactory.CreateWithParent2(this, tcs, ET.OnceWaitTimer, ETTaskCompletionSource_1Boolean)
        this.timers:set(timer.Id, timer)
        AddToTimeId(this, tillTime, timer.Id)

        local instanceId = timer.InstanceId
        cancellationToken:Register(function ()
          if instanceId ~= timer.InstanceId then
            return
          end

          timer:Run(false)

          Remove(this, timer.Id)
        end)
        return async:Await(tcs:getTask())
      end, nil, this, tillTime, cancellationToken)
    end
    WaitTillAsync1 = function (this, tillTime)
      return System.async(function (async, this, tillTime)
        if ET.TimeHelper.Now() > tillTime then
          return true
        end
        local tcs = ETTaskCompletionSource_1Boolean()
        local timer = ET.EntityFactory.CreateWithParent2(this, tcs, ET.OnceWaitTimer, ETTaskCompletionSource_1Boolean)
        this.timers:set(timer.Id, timer)
        AddToTimeId(this, tillTime, timer.Id)
        return async:Await(tcs:getTask())
      end, nil, this, tillTime)
    end
    WaitAsync = function (this, time, cancellationToken)
      return System.async(function (async, this, time, cancellationToken)
        local tillTime = ET.TimeHelper.Now() + time

        if ET.TimeHelper.Now() > tillTime then
          return true
        end

        local tcs = ETTaskCompletionSource_1Boolean()
        local timer = ET.EntityFactory.CreateWithParent2(this, tcs, ET.OnceWaitTimer, ETTaskCompletionSource_1Boolean)
        this.timers:set(timer.Id, timer)
        AddToTimeId(this, tillTime, timer.Id)
        local instanceId = timer.InstanceId
        cancellationToken:Register(function ()
          if instanceId ~= timer.InstanceId then
            return
          end

          timer:Run(false)

          Remove(this, timer.Id)
        end)
        return async:Await(tcs:getTask())
      end, nil, this, time, cancellationToken)
    end
    WaitAsync1 = function (this, time)
      return System.async(function (async, this, time)
        local tillTime = ET.TimeHelper.Now() + time
        local tcs = ETTaskCompletionSource_1Boolean()
        local timer = ET.EntityFactory.CreateWithParent2(this, tcs, ET.OnceWaitTimer, ETTaskCompletionSource_1Boolean)
        this.timers:set(timer.Id, timer)
        AddToTimeId(this, tillTime, timer.Id)
        return async:Await(tcs:getTask())
      end, nil, this, time)
    end
    -- <summary>
    -- 创建一个RepeatedTimer
    -- </summary>
    -- <param name="action"></param>
    -- <returns></returns>
    NewRepeatedTimer = function (this, time, action)
      if time < 30 then
        System.throw(System.Exception("repeated time < 30" .. ""))
      end
      local tillTime = ET.TimeHelper.Now() + time
      local timer = ET.EntityFactory.CreateWithParent3(this, time, action, ET.RepeatedTimer, System.Int64, System.Delegate)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return timer.Id
    end
    GetRepeatedTimer = function (this, id)
      local default, timer = this.timers:TryGetValue(id)
      if not default then
        return nil
      end
      return System.as(timer, ET.RepeatedTimer)
    end
    Remove = function (this, id)
      if id == 0 then
        return
      end
      local timer
      local default
      default, timer = this.timers:TryGetValue(id)
      if not default then
        return
      end
      this.timers:RemoveKey(id);

      local extern = (System.as(timer, System.IDisposable))
      if extern ~= nil then
        extern:Dispose()
      end
    end
    NewOnceTimer = function (this, tillTime, action)
      local timer = ET.EntityFactory.CreateWithParent2(this, action, ET.OnceTimer, System.Delegate)
      this.timers:set(timer.Id, timer)
      AddToTimeId(this, tillTime, timer.Id)
      return timer.Id
    end
    GetOnceTimer = function (this, id)
      local default, timer = this.timers:TryGetValue(id)
      if not default then
        return nil
      end
      return System.as(timer, ET.OnceTimer)
    end
    AddToTimeId = function (this, tillTime, id)
      this.TimeId:Add(tillTime, id)
      if tillTime < this.minTime then
        this.minTime = tillTime
      end
    end
    return {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      minTime = 0,
      Update = Update,
      WaitTillAsync = WaitTillAsync,
      WaitTillAsync1 = WaitTillAsync1,
      WaitAsync = WaitAsync,
      WaitAsync1 = WaitAsync1,
      NewRepeatedTimer = NewRepeatedTimer,
      GetRepeatedTimer = GetRepeatedTimer,
      Remove = Remove,
      NewOnceTimer = NewOnceTimer,
      GetOnceTimer = GetOnceTimer,
      AddToTimeId = AddToTimeId,
      __ctor__ = __ctor__
    }
  end)
end)
