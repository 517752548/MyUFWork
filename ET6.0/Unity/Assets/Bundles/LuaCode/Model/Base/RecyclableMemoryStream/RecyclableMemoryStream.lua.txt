-- Generated by CSharp.lua Compiler
-- The MIT License (MIT)
-- 
-- Copyright (c) 2015-2016 Microsoft
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
local System = System
local SystemIO = System.IO
local ArrayByte = System.Array(System.Byte)
local ListArrayByte = System.List(ArrayByte)
local RecyclableMemoryStreamManager
System.import(function (out)
  RecyclableMemoryStreamManager = Microsoft.IO.RecyclableMemoryStreamManager
end)
System.namespace("Microsoft.IO", function (namespace)
  -- <summary>
  -- MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
  -- buffers.
  -- </summary>
  -- This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
  -- objects to callers, while avoiding these specific problems:
  -- 1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
  -- 2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
  -- leads to continual memory growth as each stream approaches the maximum allowed size.
  -- 3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
  -- This implementation only copies the bytes when GetBuffer is called.
  -- 4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
  -- can be easily reused.
  -- 
  -- The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
  -- additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
  -- object itself.
  -- 
  -- The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single
  -- contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks
  -- are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,
  -- split by size--they are multiples of a chunk size (1 MB by default).
  -- 
  -- Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the
  -- large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers
  -- are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
  -- 
  -- </remarks>
  namespace.class("RecyclableMemoryStream", function (namespace)
    local emptyArray, getId, getTag, getMemoryManager, __gc, Dispose, Close, getCapacity, 
    setCapacity, getLength, getPosition, setPosition, getCanRead, getCanSeek, getCanTimeout, getCanWrite, 
    GetBuffer, ToArray, Read, SafeRead, Write, ToString, WriteByte, ReadByte, 
    SafeReadByte, SetLength, Seek, WriteTo, getDisposed, CheckDisposed, InternalRead, GetBlockAndRelativeOffset, 
    EnsureCapacity, ReleaseLargeBuffer, class, static, internal, __ctor1__, __ctor2__, __ctor3__, 
    __ctor4__
    namespace.struct("BlockAndOffset", function (namespace)
      local __ctor__
      __ctor__ = function (this, block, offset)
        if block == nil then
          return
        end
        this.Block = block
        this.Offset = offset
      end
      return {
        Block = 0,
        Offset = 0,
        __ctor__ = __ctor__
      }
    end)
    static = function (this)
      emptyArray = ArrayByte:new(0)
    end
    internal = function (this)
      this.blocks = ListArrayByte(1)
      this.byteBuffer = ArrayByte:new(1)
      this.id = System.default(System.Guid)
    end
    -- <summary>
    -- Allocate a new RecyclableMemoryStream object.
    -- </summary>
    __ctor1__ = function (this, memoryManager)
      __ctor4__(this, memoryManager, nil, 0)
    end
    -- <summary>
    -- Allocate a new RecyclableMemoryStream object
    -- </summary>
    -- <param name="tag">A string identifying this stream for logging and debugging purposes</param>
    __ctor2__ = function (this, memoryManager, tag)
      __ctor4__(this, memoryManager, tag, 0)
    end
    -- <summary>
    -- Allocate a new RecyclableMemoryStream object
    -- </summary>
    -- <param name="tag">A string identifying this stream for logging and debugging purposes</param>
    -- <param name="requestedSize">The initial requested size to prevent future allocations</param>
    __ctor3__ = function (this, memoryManager, tag, requestedSize)
      __ctor4__(this, memoryManager, tag, requestedSize)
    end
    -- <summary>
    -- Allocate a new RecyclableMemoryStream object
    -- </summary>
    -- <param name="tag">A string identifying this stream for logging and debugging purposes</param>
    -- <param name="requestedSize">The initial requested size to prevent future allocations</param>
    -- <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
    __ctor4__ = function (this, memoryManager, tag, requestedSize, initialLargeBuffer)
      internal(this)
      System.base(this).__ctor__(this, emptyArray)
      this.memoryManager = memoryManager
      this.id = System.Guid.NewGuid()
      this.tag = tag

      if requestedSize < memoryManager:getBlockSize() then
        requestedSize = memoryManager:getBlockSize()
      end

      if initialLargeBuffer == nil then
        EnsureCapacity(this, requestedSize)
      else
        this.largeBuffer = initialLargeBuffer
      end

      if this.memoryManager.GenerateCallStacks then
        this.AllocationStack = System.Environment.getStackTrace()
      end

      RecyclableMemoryStreamManager.Events.Writer:MemoryStreamCreated(this.id, this.tag, requestedSize)
      this.memoryManager:ReportStreamCreated()
    end
    getId = function (this)
      CheckDisposed(this)
      return this.id
    end
    getTag = function (this)
      CheckDisposed(this)
      return this.tag
    end
    getMemoryManager = function (this)
      CheckDisposed(this)
      return this.memoryManager
    end
    __gc = function (this)
      Dispose(this, false)
    end
    -- <summary>
    -- Returns the memory used by this stream back to the pool.
    -- </summary>
    Dispose = function (this, disposing)
      local default
      default, this.disposedState = System.Interlocked.CompareExchange(this.disposedState, 1, 0)
      if default ~= 0 then
        local doubleDisposeStack = nil
        if this.memoryManager.GenerateCallStacks then
          doubleDisposeStack = System.Environment.getStackTrace()
        end

        RecyclableMemoryStreamManager.Events.Writer:MemoryStreamDoubleDispose(this.id, this.tag, this.AllocationStack, this.DisposeStack, doubleDisposeStack)
        return
      end

      RecyclableMemoryStreamManager.Events.Writer:MemoryStreamDisposed(this.id, this.tag)

      if this.memoryManager.GenerateCallStacks then
        this.DisposeStack = System.Environment.getStackTrace()
      end

      if disposing then
        this.memoryManager:ReportStreamDisposed()

        System.GC.SuppressFinalize(this)
      else
        -- We're being finalized.

        RecyclableMemoryStreamManager.Events.Writer:MemoryStreamFinalized(this.id, this.tag, this.AllocationStack)


        if System.AppDomain.getCurrentDomain():IsFinalizingForUnload() then
          -- If we're being finalized because of a shutdown, don't go any further.
          -- We have no idea what's already been cleaned up. Triggering events may cause
          -- a crash.
          System.base(this).Dispose(this, disposing)
          return
        end


        this.memoryManager:ReportStreamFinalized()
      end

      this.memoryManager:ReportStreamLength(this.length)

      if this.largeBuffer ~= nil then
        this.memoryManager:ReturnLargeBuffer(this.largeBuffer, this.tag)
      end

      if this.dirtyBuffers ~= nil then
        for _, buffer in System.each(this.dirtyBuffers) do
          this.memoryManager:ReturnLargeBuffer(buffer, this.tag)
        end
      end

      this.memoryManager:ReturnBlocks(this.blocks, this.tag)
      this.blocks:Clear()

      System.base(this).Dispose(this, disposing)
    end
    -- <summary>
    -- Equivalent to Dispose
    -- </summary>
    Close = function (this)
      Dispose(this, true)
    end
    getCapacity = function (this)
      CheckDisposed(this)
      if this.largeBuffer ~= nil then
        return #this.largeBuffer
      end

      local size = #this.blocks * this.memoryManager:getBlockSize()
      return System.toInt32(math.Min(2147483647 --[[Int32.MaxValue]], size))
    end
    setCapacity = function (this, value)
      CheckDisposed(this)
      EnsureCapacity(this, value)
    end
    getLength = function (this)
      CheckDisposed(this)
      return this.length
    end
    getPosition = function (this)
      CheckDisposed(this)
      return this.position
    end
    setPosition = function (this, value)
      CheckDisposed(this)
      if value < 0 then
        System.throw(System.ArgumentOutOfRangeException("value", "value must be non-negative"))
      end

      if value > 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]] then
        System.throw(System.ArgumentOutOfRangeException("value", "value cannot be more than " .. 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]]))
      end

      this.position = System.toInt32(value)
    end
    getCanRead = function (this)
      return not getDisposed(this)
    end
    getCanSeek = function (this)
      return not getDisposed(this)
    end
    getCanTimeout = function (this)
      return false
    end
    getCanWrite = function (this)
      return not getDisposed(this)
    end
    -- <summary>
    -- Returns a single buffer containing the contents of the stream.
    -- The buffer may be longer than the stream length.
    -- </summary>
    -- <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
    -- until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    GetBuffer = function (this)
      CheckDisposed(this)

      if this.largeBuffer ~= nil then
        return this.largeBuffer
      end

      if #this.blocks == 1 then
        return this.blocks:get(0)
      end

      -- Buffer needs to reflect the capacity, not the length, because
      -- it's possible that people will manipulate the buffer directly
      -- and set the length afterward. Capacity sets the expectation
      -- for the size of the buffer.
      local newBuffer = this.memoryManager:GetLargeBuffer(getCapacity(this), this.tag)

      -- InternalRead will check for existence of largeBuffer, so make sure we
      -- don't set it until after we've copied the data.
      InternalRead(this, newBuffer, 0, this.length, 0)
      this.largeBuffer = newBuffer

      if #this.blocks > 0 and this.memoryManager.AggressiveBufferReturn then
        this.memoryManager:ReturnBlocks(this.blocks, this.tag)
        this.blocks:Clear()
      end

      return this.largeBuffer
    end
    -- <summary>
    -- Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to
    -- access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
    -- for the sake of completeness.
    -- </summary>
    ToArray = function (this)
      CheckDisposed(this)
      local newBuffer = ArrayByte:new(getLength(this))

      InternalRead(this, newBuffer, 0, this.length, 0)
      local default
      if this.memoryManager.GenerateCallStacks then
        default = System.Environment.getStackTrace()
      else
        default = nil
      end
      local stack = default
      RecyclableMemoryStreamManager.Events.Writer:MemoryStreamToArray(this.id, this.tag, stack, 0)
      this.memoryManager:ReportStreamToArray()

      return newBuffer
    end
    -- <summary>
    -- Reads from the current position into the provided buffer
    -- </summary>
    -- <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
    -- <param name="count">Number of bytes to read.</param>
    -- <returns>The number of bytes read</returns>
    -- <exception cref="ArgumentNullException">buffer is null</exception>
    -- <exception cref="ArgumentOutOfRangeException">offset or count is less than 0</exception>
    -- <exception cref="ArgumentException">offset subtracted from the buffer length is less than count</exception>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    Read = function (this, buffer, offset, count)
      local default
      default, this.position = SafeRead(this, buffer, offset, count, this.position)
      return default
    end
    -- <summary>
    -- Reads from the specified position into the provided buffer
    -- </summary>
    -- <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
    -- <param name="count">Number of bytes to read.</param>
    -- <param name="streamPosition">Position in the stream to start reading from</param>
    -- <returns>The number of bytes read</returns>
    -- <exception cref="ArgumentNullException">buffer is null</exception>
    -- <exception cref="ArgumentOutOfRangeException">offset or count is less than 0</exception>
    -- <exception cref="ArgumentException">offset subtracted from the buffer length is less than count</exception>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    SafeRead = function (this, buffer, offset, count, streamPosition)
      CheckDisposed(this)
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer" --[[nameof(buffer)]]))
      end

      if offset < 0 then
        System.throw(System.ArgumentOutOfRangeException("offset" --[[nameof(offset)]], "offset cannot be negative"))
      end

      if count < 0 then
        System.throw(System.ArgumentOutOfRangeException("count" --[[nameof(count)]], "count cannot be negative"))
      end

      if offset + count > #buffer then
        System.throw(System.ArgumentException("buffer length must be at least offset + count"))
      end

      local amountRead = InternalRead(this, buffer, offset, count, streamPosition)
      streamPosition = streamPosition + amountRead
      return amountRead, streamPosition
    end
    -- <summary>
    -- Writes the buffer to the stream
    -- </summary>
    -- <param name="offset">Start position</param>
    -- <param name="count">Number of bytes to write</param>
    -- <exception cref="ArgumentNullException">buffer is null</exception>
    -- <exception cref="ArgumentOutOfRangeException">offset or count is negative</exception>
    -- <exception cref="ArgumentException">buffer.Length - offset is not less than count</exception>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    Write = function (this, buffer, offset, count)
      CheckDisposed(this)
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer" --[[nameof(buffer)]]))
      end

      if offset < 0 then
        System.throw(System.ArgumentOutOfRangeException("offset" --[[nameof(offset)]], nil, nil, offset, "Offset must be in the range of 0 - buffer.Length-1"))
      end

      if count < 0 then
        System.throw(System.ArgumentOutOfRangeException("count" --[[nameof(count)]], nil, nil, count, "count must be non-negative"))
      end

      if count + offset > #buffer then
        System.throw(System.ArgumentException("count must be greater than buffer.Length - offset"))
      end

      local blockSize = this.memoryManager:getBlockSize()
      local end_ = this.position + count
      -- Check for overflow
      if end_ > 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]] then
        System.throw(SystemIO.IOException("Maximum capacity exceeded"))
      end

      local requiredBuffers = System.div((end_ + blockSize - 1), blockSize)

      if requiredBuffers * blockSize > 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]] then
        System.throw(SystemIO.IOException("Maximum capacity exceeded"))
      end

      EnsureCapacity(this, System.toInt32(end_))

      if this.largeBuffer == nil then
        local bytesRemaining = count
        local bytesWritten = 0
        local blockAndOffset = GetBlockAndRelativeOffset(this, this.position)

        while bytesRemaining > 0 do
          local currentBlock = this.blocks:get(blockAndOffset.Block)
          local remainingInBlock = blockSize - blockAndOffset.Offset
          local amountToWriteInBlock = math.Min(remainingInBlock, bytesRemaining)

          System.Buffer.BlockCopy(buffer, offset + bytesWritten, currentBlock, blockAndOffset.Offset, amountToWriteInBlock)

          bytesRemaining = bytesRemaining - amountToWriteInBlock
          bytesWritten = bytesWritten + amountToWriteInBlock

          local default = blockAndOffset
          default.Block = default.Block + 1
          blockAndOffset.Offset = 0
        end
      else
        System.Buffer.BlockCopy(buffer, offset, this.largeBuffer, this.position, count)
      end
      this.position = System.toInt32(end_)
      this.length = math.Max(this.position, this.length)
    end
    -- <summary>
    -- Returns a useful string for debugging. This should not normally be called in actual production code.
    -- </summary>
    ToString = function (this)
      return "Id = " .. getId(this):ToString() .. ", Tag = " .. getTag(this) .. ", Length = " .. getLength(this) .. " bytes"
    end
    -- <summary>
    -- Writes a single byte to the current position in the stream.
    -- </summary>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    WriteByte = function (this, value)
      CheckDisposed(this)
      this.byteBuffer:set(0, value)
      Write(this, this.byteBuffer, 0, 1)
    end
    -- <summary>
    -- Reads a single byte from the current position in the stream.
    -- </summary>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    ReadByte = function (this)
      local default
      default, this.position = SafeReadByte(this, this.position)
      return default
    end
    -- <summary>
    -- Reads a single byte from the specified position in the stream.
    -- </summary>
    -- <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    SafeReadByte = function (this, streamPosition)
      CheckDisposed(this)
      if streamPosition == this.length then
        return - 1, streamPosition
      end
      local value
      if this.largeBuffer == nil then
        local blockAndOffset = GetBlockAndRelativeOffset(this, streamPosition)
        value = this.blocks:get(blockAndOffset.Block):get(blockAndOffset.Offset)
      else
        value = this.largeBuffer:get(streamPosition)
      end
      streamPosition = streamPosition + 1
      return value, streamPosition
    end
    -- <summary>
    -- Sets the length of the stream
    -- </summary>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    SetLength = function (this, value)
      CheckDisposed(this)
      if value < 0 or value > 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]] then
        System.throw(System.ArgumentOutOfRangeException("value" --[[nameof(value)]], "value must be non-negative and at most " .. 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]]))
      end

      EnsureCapacity(this, System.toInt32(value))

      this.length = System.toInt32(value)
      if this.position > value then
        this.position = System.toInt32(value)
      end
    end
    -- <summary>
    -- Sets the position to the offset from the seek location
    -- </summary>
    -- <param name="loc">From where</param>
    -- <returns>The new position</returns>
    -- <exception cref="ObjectDisposedException">Object has been disposed</exception>
    -- <exception cref="ArgumentOutOfRangeException">offset is larger than MaxStreamLength</exception>
    -- <exception cref="ArgumentException">Invalid seek origin</exception>
    -- <exception cref="IOException">Attempt to set negative position</exception>
    Seek = function (this, offset, loc)
      CheckDisposed(this)
      if offset > 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]] then
        System.throw(System.ArgumentOutOfRangeException("offset" --[[nameof(offset)]], "offset cannot be larger than " .. 2147483647 --[[RecyclableMemoryStream.MaxStreamLength]]))
      end

      local newPosition
      repeat
        local default = loc
        if default == SystemIO.SeekOrigin.Begin then
          newPosition = System.toInt32(offset)
          break
        elseif default == SystemIO.SeekOrigin.Current then
          newPosition = System.toInt32(offset) + this.position
          break
        elseif default == SystemIO.SeekOrigin.End then
          newPosition = System.toInt32(offset) + this.length
          break
        else
          System.throw(System.ArgumentException("Invalid seek origin", "loc" --[[nameof(loc)]]))
        end
      until 1
      if newPosition < 0 then
        System.throw(SystemIO.IOException("Seek before beginning"))
      end
      this.position = newPosition
      return this.position
    end
    -- <summary>
    -- Synchronously writes this stream's bytes to the parameter stream.
    -- </summary>
    -- <remarks>Important: This does a synchronous write, which may not be desired in some situations</remarks>
    WriteTo = function (this, stream)
      CheckDisposed(this)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream" --[[nameof(stream)]]))
      end

      if this.largeBuffer == nil then
        local currentBlock = 0
        local bytesRemaining = this.length

        while bytesRemaining > 0 do
          local amountToCopy = math.Min(#this.blocks:get(currentBlock), bytesRemaining)
          stream:Write(this.blocks:get(currentBlock), 0, amountToCopy)

          bytesRemaining = bytesRemaining - amountToCopy

          currentBlock = currentBlock + 1
        end
      else
        stream:Write(this.largeBuffer, 0, this.length)
      end
    end
    getDisposed = function (this)
      local default
      default, this.disposedState = System.Interlocked.Read(this.disposedState)
      return default ~= 0
    end
    CheckDisposed = function (this)
      if getDisposed(this) then
        System.throw(System.ObjectDisposedException("The stream with Id " .. this.id:ToString() .. " and Tag " .. this.tag .. " is disposed."))
      end
    end
    InternalRead = function (this, buffer, offset, count, fromPosition)
      if this.length - fromPosition <= 0 then
        return 0
      end

      local amountToCopy

      if this.largeBuffer == nil then
        local blockAndOffset = GetBlockAndRelativeOffset(this, fromPosition)
        local bytesWritten = 0
        local bytesRemaining = math.Min(count, this.length - fromPosition)

        while bytesRemaining > 0 do
          amountToCopy = math.Min(#this.blocks:get(blockAndOffset.Block) - blockAndOffset.Offset, bytesRemaining)
          System.Buffer.BlockCopy(this.blocks:get(blockAndOffset.Block), blockAndOffset.Offset, buffer, bytesWritten + offset, amountToCopy)

          bytesWritten = bytesWritten + amountToCopy
          bytesRemaining = bytesRemaining - amountToCopy

          local default = blockAndOffset
          default.Block = default.Block + 1
          blockAndOffset.Offset = 0
        end
        return bytesWritten
      end
      amountToCopy = math.Min(count, this.length - fromPosition)
      System.Buffer.BlockCopy(this.largeBuffer, fromPosition, buffer, offset, amountToCopy)
      return amountToCopy
    end
    GetBlockAndRelativeOffset = function (this, offset)
      local blockSize = this.memoryManager:getBlockSize()
      return class.BlockAndOffset(System.div(offset, blockSize), System.mod(offset, blockSize))
    end
    EnsureCapacity = function (this, newCapacity)
      if newCapacity > this.memoryManager.MaximumStreamCapacity and this.memoryManager.MaximumStreamCapacity > 0 then
        RecyclableMemoryStreamManager.Events.Writer:MemoryStreamOverCapacity(newCapacity, this.memoryManager.MaximumStreamCapacity, this.tag, this.AllocationStack)
        System.throw(System.InvalidOperationException("Requested capacity is too large: " .. newCapacity .. ". Limit is " .. this.memoryManager.MaximumStreamCapacity))
      end

      if this.largeBuffer ~= nil then
        if newCapacity > #this.largeBuffer then
          local newBuffer = this.memoryManager:GetLargeBuffer(newCapacity, this.tag)
          InternalRead(this, newBuffer, 0, this.length, 0)
          ReleaseLargeBuffer(this)
          this.largeBuffer = newBuffer
        end
      else
        while getCapacity(this) < newCapacity do
          this.blocks:Add((this.memoryManager:GetBlock()))
        end
      end
    end
    -- <summary>
    -- Release the large buffer (either stores it for eventual release or returns it immediately).
    -- </summary>
    ReleaseLargeBuffer = function (this)
      if this.memoryManager.AggressiveBufferReturn then
        this.memoryManager:ReturnLargeBuffer(this.largeBuffer, this.tag)
      else
        if this.dirtyBuffers == nil then
          -- We most likely will only ever need space for one
          this.dirtyBuffers = ListArrayByte(1)
        end
        this.dirtyBuffers:Add(this.largeBuffer)
      end

      this.largeBuffer = nil
    end
    class = {
      base = function (out)
        return {
          System.IO.MemoryStream
        }
      end,
      disposedState = 0,
      getId = getId,
      getTag = getTag,
      getMemoryManager = getMemoryManager,
      __gc = __gc,
      Dispose = Dispose,
      Close = Close,
      getCapacity = getCapacity,
      setCapacity = setCapacity,
      length = 0,
      getLength = getLength,
      position = 0,
      getPosition = getPosition,
      setPosition = setPosition,
      getCanRead = getCanRead,
      getCanSeek = getCanSeek,
      getCanTimeout = getCanTimeout,
      getCanWrite = getCanWrite,
      GetBuffer = GetBuffer,
      ToArray = ToArray,
      Read = Read,
      SafeRead = SafeRead,
      Write = Write,
      ToString = ToString,
      WriteByte = WriteByte,
      ReadByte = ReadByte,
      SafeReadByte = SafeReadByte,
      SetLength = SetLength,
      Seek = Seek,
      WriteTo = WriteTo,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__,
        __ctor3__,
        __ctor4__
      },
      __metadata__ = function (out)
        return {
          methods = {
            { "Dispose", 0x103, Dispose, System.Boolean, System.apply(System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Usage", "CA1816:CallGCSuppressFinalizeCorrectly"), function (default) default:setJustification("We have different disposal semantics, so SuppressFinalize is in a different spot.") end) },
            { "ToArray", 0x86, ToArray, System.Array(System.Byte), System.ObsoleteAttribute("This method has degraded performance vs. GetBuffer and should be avoided.") }
          }
        }
      end
    }
    return class
  end)
end)
