-- Generated by CSharp.lua Compiler
local System = System
local ICSharpCodeCompression = ICSharpCode.SharpZipLib.Zip.Compression
local SystemIO = System.IO
local ArrayByte = System.Array(System.Byte)
System.namespace("ET", function (namespace)
  namespace.class("ZipHelper", function (namespace)
    local Compress, Decompress, Decompress1
    Compress = function (content)
      --return content;
      local compressor = ICSharpCodeCompression.Deflater()
      compressor:SetLevel(9 --[[Deflater.BEST_COMPRESSION]])

      compressor:SetInput(content)
      compressor:Finish()

      local default, extern = System.using(SystemIO.MemoryStream(#content), function (bos)
        local buf = ArrayByte:new(1024)
        while not compressor:getIsFinished() do
          local n = compressor:Deflate(buf)
          bos:Write(buf, 0, n)
        end
        return true, bos:ToArray()
      end)
      if default then
        return extern
      end
    end
    Decompress = function (content)
      return Decompress1(content, 0, #content)
    end
    Decompress1 = function (content, offset, count)
      --return content;
      local decompressor = ICSharpCodeCompression.Inflater()
      decompressor:SetInput(content, offset, count)

      local default, extern = System.using(SystemIO.MemoryStream(#content), function (bos)
        local buf = ArrayByte:new(1024)
        while not decompressor:getIsFinished() do
          local n = decompressor:Inflate(buf)
          bos:Write(buf, 0, n)
        end
        return true, bos:ToArray()
      end)
      if default then
        return extern
      end
    end
    return {
      Compress = Compress,
      Decompress = Decompress,
      Decompress1 = Decompress1
    }
  end)
end)
--[[
using System.IO;
using System.IO.Compression;

namespace ET
{
	public static class ZipHelper
	{
		public static byte[] Compress(byte[] content)
		{
			using (MemoryStream ms = new MemoryStream())
			using (DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true))
			{
				stream.Write(content, 0, content.Length);
				return ms.ToArray();
			}
		}

		public static byte[] Decompress(byte[] content)
		{
			return Decompress(content, 0, content.Length);
		}

		public static byte[] Decompress(byte[] content, int offset, int count)
		{
			using (MemoryStream ms = new MemoryStream())
			using (DeflateStream stream = new DeflateStream(new MemoryStream(content, offset, count), CompressionMode.Decompress, true))
			{
				byte[] buffer = new byte[1024];
				while (true)
				{
					int bytesRead = stream.Read(buffer, 0, 1024);
					if (bytesRead == 0)
					{
						break;
					}
					ms.Write(buffer, 0, bytesRead);
				}
				return ms.ToArray();
			}
		}
	}
}
]]
